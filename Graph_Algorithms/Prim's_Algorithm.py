"""
Алгоритм Прима (Prim's Algorithm) – это алгоритм на графах, который также используется для нахождения минимального
остовного дерева в связном взвешенном графе. Этот алгоритм начинает с одной начальной вершины и постепенно добавляет
к ней ребра с наименьшими весами, расширяя остовное дерево.

Шаги алгоритма Прима:
1) Инициализация: Выберите начальную вершину и поместите ее в остовное дерево. Установите расстояние от начальной
вершины до всех остальных вершин в бесконечность.
2) Выбор ребра: Пока все вершины не будут включены в остовное дерево, найдите ребро с наименьшим весом,
которое соединяет вершину из остовного дерева с вершиной за его пределами.
3) Добавление вершины: Добавьте найденное ребро к остовному дереву и пометьте соответствующую вершину как посещенную.
4) Повторение: Повторяйте шаги 2 и 3 до тех пор, пока не будут включены все вершины в остовное дерево.
"""

import heapq


def prim_algorithm(graph, start):
    min_spanning_tree = []
    visited = set()
    heap = [(0, start)]

    while heap:
        weight, node = heapq.heappop(heap)
        if node not in visited:
            visited.add(node)
            if node != start:
                min_spanning_tree.append((parent, node, weight))
            for neighbor, edge_weight in graph[node]:
                if neighbor not in visited:
                    heapq.heappush(heap, (edge_weight, neighbor))
    return min_spanning_tree


# Пример графа в виде словаря списков смежности с весами
graph = {
    'A': [('B', 2), ('C', 5)],
    'B': [('A', 2), ('C', 1)],
    'C': [('B', 1), ('A', 5)]
}

# Вызов функции с начальной вершиной 'A'
start_vertex = 'A'
min_spanning_tree = prim_algorithm(graph, start_vertex)
print(min_spanning_tree)

"""
Алгоритм Прима также эффективно находит минимальное остовное дерево в графе, подобно алгоритму Краскала, 
и может быть использован для различных задач, требующих поиска оптимальных путей в графах.
"""
