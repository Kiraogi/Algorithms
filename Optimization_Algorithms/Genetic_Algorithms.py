"""
Генетические алгоритмы — это методы поиска и оптимизации, вдохновленные процессами естественного отбора и генетики.
Они используются для решения сложных задач, где традиционные методы неэффективны. Генетические алгоритмы оперируют
популяцией потенциальных решений, которые называются индивидами или хромосомами, и эти решения кодируются обычно
в виде строк, например, бинарных строк.

Генетический алгоритм обычно включает в себя следующие этапы:
1) Начальная популяция: Создание начальной популяции случайным образом или с помощью эвристического метода.
2) Оценка пригодности: Оценка каждого индивида в популяции для определения его пригодности.
3) Селекция: Выбор лучших индивидов, которые будут использоваться для создания следующего поколения.
4)Кроссовер (скрещивание): Сочетание частей двух индивидов для создания потомства.
5)Мутация: Внесение небольших изменений в индивидов для поддержания генетического разнообразия.
6)Новое поколение: Замена некоторой части текущей популяции потомством, полученным после кроссовера и мутации.
7)Повторение процесса: Повторение шагов 2–6 до тех пор, пока не будет достигнут критерий останова, например,
заданное количество поколений или достижение приемлемого уровня пригодности.

Вот простой пример псевдокода генетического алгоритма:
инициализировать популяцию
пока не достигнут критерий останова:
    оценить пригодность каждого индивида в популяции
    выбрать лучших индивидов для размножения
    создать новое поколение путем кроссовера и мутации
    заменить часть популяции новым поколением
возвратить лучшего индивида как решение задачи

Применение генетического алгоритма требует тщательного выбора функции пригодности, способа представления индивидов,
вероятностей кроссовера и мутации, а также стратегии селекции. Эти параметры значительно влияют на эффективность и
скорость сходимости алгоритма.
"""

"""
Рассмотрим оптимизацию портфеля инвестиций. Цель состоит в том, чтобы распределить заданный капитал между набором 
активов таким образом, чтобы максимизировать ожидаемую доходность при заданном уровне риска. 
Генетические алгоритмы могут помочь в поиске оптимального распределения.

В этом примере мы будем использовать Python и библиотеку DEAP для создания генетического алгоритма. 
Установите DEAP, если он еще не установлен:
pip install deap
"""

import random
from deap import base, creator, tools, algorithms

# Предположим, у нас есть 4 актива с ожидаемой доходностью и стандартным отклонением (риск)
assets = [
    {'return': 0.12, 'risk': 0.04},
    {'return': 0.08, 'risk': 0.03},
    {'return': 0.14, 'risk': 0.05},
    {'return': 0.10, 'risk': 0.03}
]

# Параметры генетического алгоритма
POPULATION_SIZE = 100
P_CROSSOVER = 0.9
P_MUTATION = 0.1
MAX_GENERATIONS = 50
HALL_OF_FAME_SIZE = 1


# Функция пригодности: Максимизация доходности при ограниченном риске
def fitness(individual):
    port_return = sum(ind['return'] * alloc for ind, alloc in zip(assets, individual))
    port_risk = sum(ind['risk'] * alloc for ind, alloc in zip(assets, individual))
    return port_return - port_risk,  # Кортеж, т.к. DEAP ожидает именно кортеж


# Создание типов для генетического алгоритма
creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, 0, 1)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, len(assets))
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

toolbox.register("evaluate", fitness)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.1)
toolbox.register("select", tools.selTournament, tournsize=3)

# Генерация начальной популяции
population = toolbox.population(n=POPULATION_SIZE)

# Алгоритм эволюции
hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("avg", numpy.mean)
stats.register("min", numpy.min)
stats.register("max", numpy.max)

population, logbook = algorithms.eaSimple(population, toolbox, cxpb=P_CROSSOVER, mutpb=P_MUTATION,
                                          ngen=MAX_GENERATIONS, stats=stats, halloffame=hof, verbose=True)

# Лучшее решение
best_portfolio = hof.items[0]
print("Best Portfolio:", best_portfolio)
print("Best Portfolio Return-Risk:", fitness(best_portfolio))

"""
В этом коде мы используем DEAP для создания индивидуумов, представляющих распределение капитала между активами. 
Функция пригодности оценивает ожидаемую доходность за вычетом риска, а лучшие индивидуумы сохраняются 
в зале славы (Hall of Fame). Обратите внимание, что в реальной задаче оптимизации портфеля вам, возможно, 
потребуется более сложная модель для оценки риска, такая как ковариация между активами.
"""
