"""
Метод отжига (Simulated Annealing) — это вероятностный алгоритм оптимизации, который находит приближенное решение задачи
глобальной оптимизации, особенно в больших пространствах поиска. Алгоритм вдохновлен процессом отжига в металлургии,
где материал нагревается и медленно охлаждается для уменьшения дефектов, увеличения размера кристаллов и минимизации
его внутренней энергии.

В контексте оптимизации метод отжига работает следующим образом:
1) Начальное решение: Алгоритм начинается с некоторого случайного решения.
2) Начальная температура: Задается начальная "температура", которая со временем будет понижаться.
3) Выбор соседнего решения: На каждом шаге алгоритма выбирается "соседнее" решение (например, с небольшим изменением
от текущего).
4) Оценка решения: Оценивается новое решение и сравнивается с текущим.
5) Принятие решения: Если новое решение лучше, оно принимается. Если оно хуже, оно может быть принято с некоторой
вероятностью, зависящей от разницы в качестве решений и текущей температуры.
6) Охлаждение: Температура понижается по некоторому графику (например, линейно или экспоненциально).
7) Критерий останова: Алгоритм продолжается до тех пор, пока не достигнут критерий останова (например, фиксированное
количество итераций или температура понизилась до определенного уровня).

Метод отжига хорошо подходит для задач, где есть много локальных оптимумов, и он помогает избежать "застревания"
в них благодаря возможности временного ухудшения решения.
"""

import math
import random


def simulated_annealing(optimize_function, initial_solution, temperature, cooling_rate, stop_temperature):
    current_solution = initial_solution
    current_value = optimize_function(current_solution)
    while temperature > stop_temperature:
        # Выбираем соседнее решение
        neighbour = get_neighbour(current_solution)
        neighbour_value = optimize_function(neighbour)

        # Вычисляем изменение "энергии"
        delta_e = neighbour_value - current_value

        # Определяем, принимаем ли новое решение
        if delta_e > 0 or math.exp(delta_e / temperature) > random.random():
            current_solution = neighbour
            current_value = neighbour_value

        # Охлаждаем систему
        temperature *= cooling_rate

    return current_solution


# Пример функции оптимизации, которая должна быть минимизирована
def optimize_function(solution):
    # Это пример функции, которая возвращает "энергию" или стоимость решения
    # Например, функция Розенброка (также известная как "выпуклая банановая функция")
    x, y = solution
    return (1 - x) ** 2 + 100 * (y - x ** 2) ** 2


# Пример функции получения соседнего решения
def get_neighbour(solution):
    # Простая реализация, которая добавляет небольшое случайное изменение к текущему решению
    neighbour = list(solution)
    index = random.randint(0, len(solution) - 1)
    neighbour[index] += random.uniform(-0.1, 0.1)  # Небольшое изменение
    return neighbour


# Начальные параметры
initial_solution = [random.uniform(-10, 10), random.uniform(-10, 10)]
temperature = 10000
cooling_rate = 0.99
stop_temperature = 1

# Запуск алгоритма
optimal_solution = simulated_annealing(optimize_function, initial_solution, temperature, cooling_rate, stop_temperature)
print("Optimal Solution:", optimal_solution)
print("Optimal Value:", optimize_function(optimal_solution))

"""
В этом примере функция optimize_function представляет собой функцию Розенброка, которая часто используется для 
тестирования алгоритмов оптимизации. Функция get_neighbour генерирует новое решение путем случайного изменения 
одной из координат текущего решения. Алгоритм отжига использует эти функции для поиска минимума функции.
"""